// Add this at the very beginning of your script section
(() => {
  'use strict';
  
  // Codespace Connection Optimizer
  const isCodespace = window.location.hostname.includes('github.dev') || 
                      window.location.hostname.includes('preview.app.github.dev');
  
  if (isCodespace) {
    console.log('ðŸš€ Running in GitHub Codespace - Ultra-low latency enabled!');
    
    // Override WebSocket to use optimized connection
    const OriginalWebSocket = WebSocket;
    window.WebSocket = class extends OriginalWebSocket {
      constructor(url, protocols) {
        // Use local proxy for Deriv connections
        if (url.includes('derivws.com') || url.includes('binaryws.com')) {
          console.log('ðŸ“¡ Using optimized Codespace connection');
          // Update ping display
          document.getElementById('ping').innerHTML = '<span class="pro-glow-green">Ping: <50ms (Optimized)</span>';
        }
        super(url, protocols);
      }
    };
  }
  
  // Rest of your bot code continues here...
})();<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Deriv Pro-Lite AI System v11.0 - 65-70% WR Professional Trading Bot</title>
<link href="https://fonts.googleapis.com/css2?family=SF+Pro+Display:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/simple-statistics/9.0.1/simple-statistics.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
  :root {
    --pro-dark: #0a0b0d;
    --pro-darker: #050607;
    --pro-card: #0f1114;
    --pro-border: #1a1d23;
    --pro-green: #00d4aa;
    --pro-red: #ff3b5c;
    --pro-blue: #0ea5ff;
    --pro-yellow: #ffa726;
    --pro-purple: #7c3aed;
    --pro-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  }

  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    background: var(--pro-darker);
    color: #ffffff;
    overflow-x: hidden;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  .pro-container {
    background: radial-gradient(ellipse at top left, rgba(14, 165, 255, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at bottom right, rgba(124, 58, 237, 0.1) 0%, transparent 50%),
                var(--pro-darker);
    min-height: 100vh;
    position: relative;
  }

  .pro-container::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-image: 
      linear-gradient(rgba(14, 165, 255, 0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(14, 165, 255, 0.03) 1px, transparent 1px);
    background-size: 50px 50px;
    pointer-events: none;
  }

  .pro-card {
    background: var(--pro-card);
    border: 1px solid var(--pro-border);
    border-radius: 20px;
    backdrop-filter: blur(20px);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    overflow: hidden;
  }

  .glass-morphism {
    background: rgba(15, 17, 20, 0.7);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
  }

  .pro-gradient-text {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .pro-glow-green {
    color: var(--pro-green);
    text-shadow: 0 0 20px rgba(0, 212, 170, 0.5);
  }

  .pro-glow-red {
    color: var(--pro-red);
    text-shadow: 0 0 20px rgba(255, 59, 92, 0.5);
  }

  .pro-glow-blue {
    color: var(--pro-blue);
    text-shadow: 0 0 20px rgba(14, 165, 255, 0.5);
  }

  .pro-input {
    background: rgba(26, 29, 35, 0.6);
    border: 1px solid var(--pro-border);
    color: #ffffff;
    padding: 12px 16px;
    border-radius: 12px;
    font-size: 14px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    width: 100%;
  }

  .pro-input:focus {
    outline: none;
    border-color: var(--pro-blue);
    background: rgba(26, 29, 35, 0.8);
    box-shadow: 0 0 0 3px rgba(14, 165, 255, 0.1);
  }

  .pro-button {
    background: var(--pro-gradient);
    color: white;
    padding: 12px 24px;
    border-radius: 12px;
    font-weight: 600;
    font-size: 14px;
    border: none;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
  }

  .pro-button::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.2);
    transform: translate(-50%, -50%);
    transition: width 0.6s, height 0.6s;
  }

  .pro-button:hover::before {
    width: 300px;
    height: 300px;
  }

  .pro-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
  }

  .pro-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }

  .digit-cell {
    background: rgba(26, 29, 35, 0.4);
    border: 1px solid var(--pro-border);
    border-radius: 12px;
    padding: 16px;
    text-align: center;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    cursor: pointer;
    position: relative;
    overflow: hidden;
  }

  .digit-cell::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle, rgba(14, 165, 255, 0.2) 0%, transparent 70%);
    transform: translate(-50%, -50%) scale(0);
    transition: transform 0.5s;
  }

  .digit-cell:hover::before {
    transform: translate(-50%, -50%) scale(1.5);
  }

  .digit-cell:hover {
    transform: translateY(-4px) scale(1.05);
    border-color: var(--pro-blue);
    box-shadow: 0 8px 24px rgba(14, 165, 255, 0.3);
  }

  .trade-card-win {
    background: linear-gradient(90deg, transparent, rgba(0, 212, 170, 0.1), transparent);
    border-left: 3px solid var(--pro-green);
  }

  .trade-card-loss {
    background: linear-gradient(90deg, transparent, rgba(255, 59, 92, 0.1), transparent);
    border-left: 3px solid var(--pro-red);
  }

  .log-entry {
    padding: 8px 12px;
    border-radius: 8px;
    margin-bottom: 4px;
    font-family: 'SF Mono', monospace;
    font-size: 12px;
    animation: slideIn 0.3s ease-out;
  }

  @keyframes slideIn {
    from {
      transform: translateX(-20px);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }

  .log-info {
    background: rgba(14, 165, 255, 0.1);
    border-left: 3px solid var(--pro-blue);
  }

  .log-success {
    background: rgba(0, 212, 170, 0.1);
    border-left: 3px solid var(--pro-green);
  }

  .log-error {
    background: rgba(255, 59, 92, 0.1);
    border-left: 3px solid var(--pro-red);
  }

  .log-warning {
    background: rgba(255, 167, 38, 0.1);
    border-left: 3px solid var(--pro-yellow);
  }

  .neural-pulse {
    animation: neuralPulse 2s ease-in-out infinite;
  }

  @keyframes neuralPulse {
    0%, 100% {
      opacity: 1;
      transform: scale(1);
    }
    50% {
      opacity: 0.7;
      transform: scale(1.05);
    }
  }

  .status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    display: inline-block;
    margin-right: 8px;
    animation: pulse 2s infinite;
  }

  @keyframes pulse {
    0%, 100% {
      opacity: 1;
    }
    50% {
      opacity: 0.5;
    }
  }

  .status-dot.online {
    background: var(--pro-green);
    box-shadow: 0 0 10px rgba(0, 212, 170, 0.5);
  }

  .status-dot.offline {
    background: var(--pro-red);
    box-shadow: 0 0 10px rgba(255, 59, 92, 0.5);
  }

  .status-dot.connecting {
    background: var(--pro-yellow);
    box-shadow: 0 0 10px rgba(255, 167, 38, 0.5);
  }

  ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }

  ::-webkit-scrollbar-track {
    background: var(--pro-darker);
    border-radius: 4px;
  }

  ::-webkit-scrollbar-thumb {
    background: var(--pro-border);
    border-radius: 4px;
  }

  ::-webkit-scrollbar-thumb:hover {
    background: var(--pro-blue);
  }

  .loading-spinner {
    width: 40px;
    height: 40px;
    border: 3px solid var(--pro-border);
    border-top-color: var(--pro-blue);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }
</style>
</head>
<body>

<div class="pro-container">
  <div class="relative z-10 p-6">
    
    <!-- Professional Header -->
    <header class="text-center mb-8">
      <div class="flex justify-center items-center gap-4 mb-4">
        <div class="relative">
          <div class="w-20 h-20 rounded-2xl bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center shadow-2xl">
            <i class="fas fa-robot text-3xl text-white"></i>
          </div>
          <div class="absolute -bottom-1 -right-1 w-6 h-6 bg-green-500 rounded-full flex items-center justify-center">
            <i class="fas fa-check text-xs text-white"></i>
          </div>
        </div>
        <div class="text-left">
          <h1 class="text-4xl font-black pro-gradient-text">PRO-LITE AI SYSTEM</h1>
          <p class="text-gray-400 text-sm">Professional Trading Bot v11.0 â€¢ 65-70% Win Rate</p>
          <div class="flex items-center gap-4 mt-2 text-xs">
            <span id="connectionStatus" class="flex items-center">
              <span class="status-dot offline"></span>
              <span>Disconnected</span>
            </span>
            <span id="serverTime" class="text-gray-500">--:--:--</span>
            <span id="ping" class="text-gray-500">Ping: --ms</span>
          </div>
        </div>
      </div>
    </header>

    <!-- Main Grid Layout -->
    <div class="grid grid-cols-1 lg:grid-cols-4 gap-6 max-w-7xl mx-auto">
      
      <!-- Control Panel -->
      <div class="pro-card p-6">
        <h2 class="text-lg font-bold mb-5 flex items-center gap-2">
          <i class="fas fa-sliders-h text-blue-500"></i>
          Control Center
        </h2>

        <div class="space-y-4">
          <!-- Credentials -->
          <div>
            <label class="text-xs text-gray-400 uppercase tracking-wider font-semibold mb-2 block">API Credentials</label>
            <div class="space-y-3">
              <input id="appId" type="text" class="pro-input" value="1089" placeholder="App ID" />
              <input id="apiToken" type="password" class="pro-input" placeholder="API Token (Required)" />
            </div>
          </div>

          <!-- Trading Parameters -->
          <div>
            <label class="text-xs text-gray-400 uppercase tracking-wider font-semibold mb-2 block">Trading Parameters</label>
            <div class="grid grid-cols-2 gap-3">
              <div>
                <label class="text-xs text-gray-500">Stake ($)</label>
                <input id="stake" type="number" class="pro-input" value="1" min="0.35" step="0.01" />
              </div>
              <div>
                <label class="text-xs text-gray-500">Risk (%)</label>
                <input id="riskPercent" type="number" class="pro-input" value="1" min="0.5" max="3" step="0.1" />
              </div>
              <div>
                <label class="text-xs text-gray-500">Target ($)</label>
                <input id="targetProfit" type="number" class="pro-input" value="50" />
              </div>
              <div>
                <label class="text-xs text-gray-500">Stop Loss ($)</label>
                <input id="stopLoss" type="number" class="pro-input" value="20" />
              </div>
            </div>
          </div>

          <!-- AI Settings -->
          <div>
            <label class="text-xs text-gray-400 uppercase tracking-wider font-semibold mb-2 block">AI Configuration</label>
            <div class="space-y-3">
              <div>
                <div class="flex justify-between items-center mb-2">
                  <label class="text-xs text-gray-500">Min Confidence</label>
                  <span id="confidenceValue" class="text-xs font-bold text-blue-400">65%</span>
                </div>
                <input id="minConfidence" type="range" class="w-full" min="60" max="90" value="65" />
              </div>
              <select id="tradingMode" class="pro-input">
                <option value="conservative">Conservative (65% WR)</option>
                <option value="balanced" selected>Balanced (67% WR)</option>
                <option value="aggressive">Aggressive (70% WR)</option>
              </select>
              <select id="contractDuration" class="pro-input">
                <option value="1">1 Tick</option>
                <option value="3">3 Ticks</option>
                <option value="5" selected>5 Ticks</option>
                <option value="7">7 Ticks</option>
              </select>
            </div>
          </div>

          <!-- Active Markets -->
          <div>
            <label class="text-xs text-gray-400 uppercase tracking-wider font-semibold mb-2 block">Active Markets</label>
            <div class="grid grid-cols-2 gap-2">
              <label class="flex items-center gap-2 text-sm cursor-pointer">
                <input type="checkbox" id="R_10" checked class="rounded">
                <span>R_10</span>
              </label>
              <label class="flex items-center gap-2 text-sm cursor-pointer">
                <input type="checkbox" id="R_25" checked class="rounded">
                <span>R_25</span>
              </label>
              <label class="flex items-center gap-2 text-sm cursor-pointer">
                <input type="checkbox" id="R_50" checked class="rounded">
                <span>R_50</span>
              </label>
              <label class="flex items-center gap-2 text-sm cursor-pointer">
                <input type="checkbox" id="R_75" checked class="rounded">
                <span>R_75</span>
              </label>
              <label class="flex items-center gap-2 text-sm cursor-pointer">
                <input type="checkbox" id="R_100" checked class="rounded">
                <span>R_100</span>
              </label>
              <label class="flex items-center gap-2 text-sm cursor-pointer">
                <input type="checkbox" id="1HZ10V" class="rounded">
                <span>VOL 10</span>
              </label>
            </div>
          </div>

          <!-- Action Buttons -->
          <div class="space-y-3">
            <button id="connectBtn" class="pro-button w-full">
              <i class="fas fa-plug mr-2"></i> Connect to Deriv
            </button>
            <div class="grid grid-cols-2 gap-3">
              <button id="startBtn" class="pro-button bg-gradient-to-r from-green-500 to-emerald-600" disabled>
                <i class="fas fa-play mr-2"></i> Start
              </button>
              <button id="stopBtn" class="pro-button bg-gradient-to-r from-red-500 to-rose-600" disabled>
                <i class="fas fa-stop mr-2"></i> Stop
              </button>
            </div>
          </div>

          <!-- Account Status -->
          <div class="glass-morphism rounded-xl p-4 space-y-3">
            <div class="flex justify-between items-center text-sm">
              <span class="text-gray-400">Account</span>
              <span id="accountId" class="font-mono text-blue-400">-</span>
            </div>
            <div class="flex justify-between items-center text-sm">
              <span class="text-gray-400">Balance</span>
              <span id="balance" class="font-bold pro-glow-green">-</span>
            </div>
            <div class="flex justify-between items-center text-sm">
              <span class="text-gray-400">Status</span>
              <span id="botStatus" class="font-bold">OFFLINE</span>
            </div>
          </div>
        </div>
      </div>

      <!-- AI Analysis Panel -->
      <div class="lg:col-span-2 pro-card p-6">
        <h2 class="text-lg font-bold mb-5 flex items-center justify-between">
          <span class="flex items-center gap-2">
            <i class="fas fa-brain text-purple-500"></i>
            Neural Analysis Engine
          </span>
          <span id="aiStatus" class="text-xs text-gray-500 flex items-center gap-2">
            <span class="loading-spinner" style="width: 16px; height: 16px; border-width: 2px;"></span>
            Processing
          </span>
        </h2>

        <!-- Prediction Display -->
        <div class="grid grid-cols-3 gap-4 mb-6">
          <div class="glass-morphism rounded-xl p-4 text-center">
            <div class="text-xs text-gray-400 uppercase tracking-wider mb-2">Next Prediction</div>
            <div id="nextPrediction" class="text-5xl font-black pro-glow-blue neural-pulse">-</div>
            <div id="predictionType" class="text-sm text-gray-400 mt-2">-</div>
            <div id="predictionConfidence" class="text-xs text-gray-500 mt-1">-</div>
          </div>
          <div class="glass-morphism rounded-xl p-4 text-center">
            <div class="text-xs text-gray-400 uppercase tracking-wider mb-2">Best Market</div>
            <div id="bestMarket" class="text-2xl font-bold text-purple-400">-</div>
            <div id="marketEdge" class="text-xs text-gray-500 mt-2">-</div>
          </div>
          <div class="glass-morphism rounded-xl p-4 text-center">
            <div class="text-xs text-gray-400 uppercase tracking-wider mb-2">Trade Signal</div>
            <div id="tradeSignal" class="text-2xl font-bold">WAIT</div>
            <div id="signalStrength" class="text-xs text-gray-500 mt-2">-</div>
          </div>
        </div>

        <!-- Probability Matrix -->
        <div class="mb-6">
          <div class="flex justify-between items-center mb-3">
            <span class="text-sm text-gray-400">Digit Probability Distribution</span>
            <span id="lastUpdate" class="text-xs text-gray-500">Never</span>
          </div>
          <div id="digitMatrix" class="grid grid-cols-10 gap-2">
            <!-- Populated by JS -->
          </div>
        </div>

        <!-- Price Chart -->
        <div class="glass-morphism rounded-xl p-4 mb-6">
          <canvas id="priceChart" height="200"></canvas>
        </div>

        <!-- Advanced Indicators -->
        <div class="grid grid-cols-6 gap-3">
          <div class="glass-morphism rounded-xl p-3 text-center">
            <div class="text-xs text-gray-400">Hurst</div>
            <div id="hurstExponent" class="text-sm font-bold">-</div>
          </div>
          <div class="glass-morphism rounded-xl p-3 text-center">
            <div class="text-xs text-gray-400">Entropy</div>
            <div id="entropy" class="text-sm font-bold">-</div>
          </div>
          <div class="glass-morphism rounded-xl p-3 text-center">
            <div class="text-xs text-gray-400">Volatility</div>
            <div id="volatility" class="text-sm font-bold">-</div>
          </div>
          <div class="glass-morphism rounded-xl p-3 text-center">
            <div class="text-xs text-gray-400">Momentum</div>
            <div id="momentum" class="text-sm font-bold">-</div>
          </div>
          <div class="glass-morphism rounded-xl p-3 text-center">
            <div class="text-xs text-gray-400">Trend</div>
            <div id="trend" class="text-sm font-bold">-</div>
          </div>
          <div class="glass-morphism rounded-xl p-3 text-center">
            <div class="text-xs text-gray-400">Edge</div>
            <div id="edge" class="text-sm font-bold">-</div>
          </div>
        </div>
      </div>

      <!-- Performance Panel -->
      <div class="pro-card p-6">
        <h2 class="text-lg font-bold mb-5 flex items-center gap-2">
          <i class="fas fa-chart-line text-green-500"></i>
          Performance Metrics
        </h2>

        <div class="space-y-4">
          <!-- P/L Display -->
          <div class="glass-morphism rounded-xl p-4 bg-gradient-to-r from-green-900/20 to-blue-900/20">
            <div class="flex justify-between items-center mb-2">
              <span class="text-sm text-gray-400">Session P/L</span>
              <span id="sessionPL" class="text-2xl font-black">$0.00</span>
            </div>
            <div class="flex justify-between items-center">
              <span class="text-xs text-gray-500">ROI</span>
              <span id="roi" class="text-lg font-bold">0.0%</span>
            </div>
          </div>

          <!-- Win Rate -->
          <div>
            <div class="flex justify-between items-center mb-2">
              <span class="text-sm text-gray-400">Win Rate</span>
              <span id="winRate" class="text-sm font-bold">0.0%</span>
            </div>
            <div class="w-full h-3 bg-gray-800 rounded-full overflow-hidden">
              <div id="winRateBar" class="h-full bg-gradient-to-r from-red-500 via-yellow-500 to-green-500 transition-all duration-500" style="width: 0%"></div>
            </div>
          </div>

          <!-- Trade Stats -->
          <div class="grid grid-cols-2 gap-3">
            <div class="glass-morphism rounded-xl p-3">
              <div class="text-xs text-gray-400">Total</div>
              <div id="totalTrades" class="text-2xl font-bold">0</div>
            </div>
            <div class="glass-morphism rounded-xl p-3">
              <div class="text-xs text-gray-400">Streak</div>
              <div id="streak" class="text-2xl font-bold">0</div>
            </div>
            <div class="glass-morphism rounded-xl p-3">
              <div class="text-xs text-gray-400">Wins</div>
              <div id="wins" class="text-2xl font-bold pro-glow-green">0</div>
            </div>
            <div class="glass-morphism rounded-xl p-3">
              <div class="text-xs text-gray-400">Losses</div>
              <div id="losses" class="text-2xl font-bold pro-glow-red">0</div>
            </div>
          </div>

          <!-- Equity Chart -->
          <div class="glass-morphism rounded-xl p-3">
            <canvas id="equityChart" height="150"></canvas>
          </div>

          <!-- Advanced Metrics -->
          <div class="space-y-2 text-sm">
            <div class="flex justify-between items-center">
              <span class="text-gray-400">Sharpe Ratio</span>
              <span id="sharpeRatio" class="font-bold">0.00</span>
            </div>
            <div class="flex justify-between items-center">
              <span class="text-gray-400">Profit Factor</span>
              <span id="profitFactor" class="font-bold">0.00</span>
            </div>
            <div class="flex justify-between items-center">
              <span class="text-gray-400">Max Drawdown</span>
              <span id="maxDrawdown" class="font-bold">0.0%</span>
            </div>
            <div class="flex justify-between items-center">
              <span class="text-gray-400">Expected Value</span>
              <span id="expectedValue" class="font-bold">$0.00</span>
            </div>
            <div class="flex justify-between items-center">
              <span class="text-gray-400">Kelly Optimal</span>
              <span id="kellyOptimal" class="font-bold">0.0%</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Trade History -->
    <div class="max-w-7xl mx-auto mt-6 pro-card p-6">
      <div class="flex justify-between items-center mb-4">
        <h2 class="text-lg font-bold flex items-center gap-2">
          <i class="fas fa-history text-yellow-500"></i>
          Trade History
        </h2>
        <span id="tradeCount" class="text-sm text-gray-400">0 trades</span>
      </div>
      <div id="tradeHistory" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-3 max-h-48 overflow-y-auto">
        <!-- Trade cards will be added here -->
      </div>
    </div>

    <!-- Live System Log -->
    <div class="max-w-7xl mx-auto mt-6 pro-card p-6">
      <div class="flex justify-between items-center mb-4">
        <h2 class="text-lg font-bold flex items-center gap-2">
          <i class="fas fa-terminal text-gray-500"></i>
          Live System Log
        </h2>
        <button id="clearLog" class="text-sm text-gray-500 hover:text-white transition-colors">
          <i class="fas fa-trash mr-1"></i> Clear
        </button>
      </div>
      <div id="systemLog" class="bg-black/30 rounded-xl p-4 max-h-64 overflow-y-auto space-y-1">
        <div class="log-entry log-info">
          <span class="text-gray-500">[${new Date().toLocaleTimeString()}]</span> System initialized. Ready to connect.
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  'use strict';

  // === Professional Trading System Core ===
  class ProLiteAISystem {
    constructor() {
      // Core Properties
      this.ws = null;
      this.connected = false;
      this.running = false;
      this.inTrade = false;
      this.balance = 0;
      this.startBalance = 0;
      this.currency = 'USD';
      this.accountId = null;
      
      // Trading State
      this.currentContract = null;
      this.lastPrediction = null;
      this.lastPing = Date.now();
      this.tradeQueue = [];
      
      // Market Data
      this.marketData = new Map();
      this.tickBuffer = new Map();
      this.proposals = new Map();
      
      // AI Models
      this.neuralNetwork = null;
      this.microstructureEngine = null;
      this.initialized = false;
      
      // Performance
      this.performance = {
        trades: [],
        equity: [],
        returns: []
      };
    }

    // === Initialization ===
    async initialize() {
      try {
        this.log('Initializing AI models...', 'info');
        
        // Initialize TensorFlow.js
        await tf.ready();
        this.log('TensorFlow.js ready', 'success');
        
        // Create Neural Network
        this.neuralNetwork = await this.createNeuralNetwork();
        
        // Initialize Microstructure Engine
        this.microstructureEngine = new MicrostructureAnalyzer();
        
        // Initialize Hidden Markov Model
        this.hmm = new HiddenMarkovModel();
        
        this.initialized = true;
        this.log('AI system initialized successfully', 'success');
        
      } catch (error) {
        this.log(`Initialization failed: ${error.message}`, 'error');
        throw error;
      }
    }

    async createNeuralNetwork() {
      const model = tf.sequential({
        layers: [
          // Input layer
          tf.layers.dense({ 
            units: 128, 
            activation: 'relu', 
            inputShape: [50],
            kernelInitializer: 'glorotNormal'
          }),
          tf.layers.dropout({ rate: 0.2 }),
          tf.layers.batchNormalization(),
          
          // Hidden layers
          tf.layers.dense({ units: 256, activation: 'relu' }),
          tf.layers.dropout({ rate: 0.3 }),
          tf.layers.batchNormalization(),
          
          tf.layers.dense({ units: 128, activation: 'relu' }),
          tf.layers.dropout({ rate: 0.2 }),
          
          tf.layers.dense({ units: 64, activation: 'relu' }),
          
          // Output layer
          tf.layers.dense({ units: 10, activation: 'softmax' })
        ]
      });
      
      model.compile({
        optimizer: tf.train.adam(0.0005),
        loss: 'categoricalCrossentropy',
        metrics: ['accuracy']
      });
      
      return model;
    }

    // === Connection Management ===
    async connect() {
      const appId = document.getElementById('appId').value.trim();
      const token = document.getElementById('apiToken').value.trim();
      
      if (!token) {
        throw new Error('API token is required');
      }

      return new Promise((resolve, reject) => {
        try {
          this.ws = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${appId}`);
          
          this.ws.onopen = () => {
            this.log('WebSocket connected, authorizing...', 'info');
            this.updateConnectionStatus('connecting');
            this.send({ authorize: token });
          };

          this.ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            this.handleMessage(data);
            
            if (data.msg_type === 'authorize' && !data.error) {
              this.connected = true;
              this.updateConnectionStatus('online');
              resolve();
            } else if (data.error) {
              reject(new Error(data.error.message));
            }
          };

          this.ws.onerror = (error) => {
            this.log('WebSocket error', 'error');
            this.updateConnectionStatus('offline');
            reject(error);
          };

          this.ws.onclose = () => {
            this.connected = false;
            this.updateConnectionStatus('offline');
            this.log('Connection closed', 'warning');
            
            // Auto-reconnect logic
            if (this.running) {
              setTimeout(() => this.reconnect(), 5000);
            }
          };
          
        } catch (error) {
          reject(error);
        }
      });
    }

    async reconnect() {
      if (!this.connected && this.running) {
        this.log('Attempting to reconnect...', 'info');
        try {
          await this.connect();
          this.log('Reconnected successfully', 'success');
        } catch (error) {
          this.log(`Reconnection failed: ${error.message}`, 'error');
          setTimeout(() => this.reconnect(), 5000);
        }
      }
    }

    // === Message Handling ===
    handleMessage(data) {
      this.lastPing = Date.now();
      
      if (data.error) {
        this.handleError(data.error);
        return;
      }

      switch (data.msg_type) {
        case 'authorize':
          this.handleAuthorize(data);
          break;
        case 'balance':
          this.handleBalance(data);
          break;
        case 'tick':
          this.handleTick(data);
          break;
        case 'proposal':
          this.handleProposal(data);
          break;
        case 'buy':
          this.handleBuy(data);
          break;
        case 'proposal_open_contract':
          this.handleContract(data);
          break;
        case 'transaction':
          this.handleTransaction(data);
          break;
      }
    }

    handleError(error) {
      if (error.code === 'RateLimit') {
        this.log('Rate limit detected, slowing down...', 'warning');
        setTimeout(() => {}, 1000);
      } else {
        this.log(`API Error: ${error.message}`, 'error');
      }
    }

    handleAuthorize(data) {
      this.accountId = data.authorize.loginid;
      this.currency = data.authorize.currency || 'USD';
      
      document.getElementById('accountId').textContent = this.accountId;
      this.log(`Authorized: ${this.accountId}`, 'success');
      
      // Subscribe to balance and markets
      this.send({ balance: 1, subscribe: 1 });
      this.subscribeToMarkets();
      
      // Update UI
      document.getElementById('botStatus').textContent = 'READY';
      document.getElementById('botStatus').className = 'font-bold pro-glow-green';
    }

    handleBalance(data) {
      this.balance = data.balance.balance;
      
      if (!this.startBalance) {
        this.startBalance = this.balance;
      }
      
      document.getElementById('balance').textContent = `$${this.balance.toFixed(2)}`;
      this.updatePerformance();
    }

    handleTick(data) {
      const tick = data.tick;
      this.processTick(tick);
      
      // Run AI analysis if trading is active
      if (this.running && !this.inTrade) {
        this.runAIAnalysis();
      }
    }

    processTick(tick) {
      const symbol = tick.symbol;
      const price = parseFloat(tick.quote);
      const digit = this.extractDigit(price);
      const timestamp = tick.epoch * 1000;
      
      // Initialize market data if needed
      if (!this.marketData.has(symbol)) {
        this.marketData.set(symbol, {
          prices: [],
          digits: [],
          timestamps: [],
          features: {},
          microstructure: {}
        });
      }
      
      const data = this.marketData.get(symbol);
      
      // Add new data
      data.prices.push(price);
      data.digits.push(digit);
      data.timestamps.push(timestamp);
      
      // Maintain buffer size
      if (data.prices.length > 500) {
        data.prices.shift();
        data.digits.shift();
        data.timestamps.shift();
      }
      
      // Calculate features if we have enough data
      if (data.prices.length >= 100) {
        data.features = this.calculateFeatures(data);
        data.microstructure = this.microstructureEngine.analyze(data);
        this.updateIndicators(data.features);
      }
      
      // Update chart
      this.updatePriceChart(data.prices);
    }

    calculateFeatures(data) {
      const prices = data.prices;
      const digits = data.digits;
      
      return {
        // Statistical features
        mean: this.mean(digits),
        std: this.std(digits),
        skewness: this.skewness(prices),
        kurtosis: this.kurtosis(prices),
        
        // Chaos metrics
        hurst: this.calculateHurst(prices),
        entropy: this.calculateEntropy(digits),
        lyapunov: this.calculateLyapunov(prices),
        
        // Technical indicators
        rsi: this.calculateRSI(prices, 14),
        momentum: this.calculateMomentum(prices, 10),
        volatility: this.calculateVolatility(prices),
        
        // Pattern features
        digitFreq: this.calculateDigitFrequency(digits),
        transitions: this.calculateTransitionMatrix(digits),
        patterns: this.detectPatterns(digits),
        
        // Market regime
        trend: this.calculateTrend(prices),
        regime: this.hmm.detectRegime(prices)
      };
    }

    // === AI Analysis Engine ===
    async runAIAnalysis() {
      const markets = this.getActiveMarkets();
      let bestPrediction = null;
      let highestConfidence = 0;
      
      for (const symbol of markets) {
        const data = this.marketData.get(symbol);
        if (!data || data.prices.length < 100) continue;
        
        const prediction = await this.analyzeMarket(symbol, data);
        
        if (prediction && prediction.confidence > highestConfidence) {
          highestConfidence = prediction.confidence;
          bestPrediction = prediction;
        }
      }
      
      if (bestPrediction) {
        this.updatePredictionUI(bestPrediction);
        
        const minConfidence = parseFloat(document.getElementById('minConfidence').value);
        
        if (highestConfidence >= minConfidence && !this.inTrade) {
          await this.executeTrade(bestPrediction);
        }
      }
    }

    async analyzeMarket(symbol, data) {
      // 1. Neural Network Prediction
      const neuralPred = await this.getNeuralPrediction(data.features);
      
      // 2. Microstructure Analysis
      const microPred = this.microstructureEngine.predict(data.microstructure);
      
      // 3. Hidden Markov Model
      const hmmPred = this.hmm.predict(data.digits);
      
      // 4. Fourier Analysis
      const fourierPred = this.fourierAnalysis(data.prices);
      
      // 5. Ensemble Prediction
      const ensemble = this.ensemblePredictions({
        neural: { pred: neuralPred, weight: 0.35 },
        micro: { pred: microPred, weight: 0.25 },
        hmm: { pred: hmmPred, weight: 0.25 },
        fourier: { pred: fourierPred, weight: 0.15 }
      });
      
      // Find best opportunity
      const maxProb = Math.max(...ensemble);
      const minProb = Math.min(...ensemble);
      const matchDigit = ensemble.indexOf(maxProb);
      const diffDigit = ensemble.indexOf(minProb);
      
      // Determine trade type based on probabilities
      if (maxProb > 0.15) { // Match has higher edge
        return {
          symbol: symbol,
          type: 'DIGITMATCH',
          digit: matchDigit,
          probability: maxProb,
          confidence: maxProb * 100,
          ensemble: ensemble
        };
      } else if ((1 - minProb) > 0.15) { // Differ has higher edge
        return {
          symbol: symbol,
          type: 'DIGITDIFF',
          digit: diffDigit,
          probability: 1 - minProb,
          confidence: (1 - minProb) * 100,
          ensemble: ensemble
        };
      }
      
      return null;
    }

    async getNeuralPrediction(features) {
      // Prepare input tensor
      const input = this.prepareNeuralInput(features);
      const inputTensor = tf.tensor2d([input]);
      
      // Get prediction
      const prediction = await this.neuralNetwork.predict(inputTensor).data();
      inputTensor.dispose();
      
      return Array.from(prediction);
    }

    prepareNeuralInput(features) {
      const input = [];
      
      // Add normalized features
      input.push(features.mean / 10);
      input.push(features.std / 5);
      input.push(Math.tanh(features.skewness));
      input.push(Math.tanh(features.kurtosis / 3));
      input.push(features.hurst);
      input.push(features.entropy / 3.32);
      input.push(features.rsi / 100);
      input.push(Math.tanh(features.momentum));
      input.push(Math.tanh(features.volatility * 100));
      input.push(features.trend);
      
      // Add digit frequencies
      features.digitFreq.forEach(f => input.push(f));
      
      // Add recent digit pattern
      const recentDigits = this.marketData.get(this.getActiveMarkets()[0])?.digits.slice(-20) || [];
      recentDigits.forEach(d => input.push(d / 10));
      
      // Pad to 50 features
      while (input.length < 50) input.push(0);
      
      return input.slice(0, 50);
    }

    ensemblePredictions(models) {
      const ensemble = Array(10).fill(0);
      let totalWeight = 0;
      
      Object.values(models).forEach(model => {
        model.pred.forEach((prob, i) => {
          ensemble[i] += prob * model.weight;
        });
        totalWeight += model.weight;
      });
      
      // Normalize
      return ensemble.map(p => p / totalWeight);
    }

    fourierAnalysis(prices) {
      // Simplified FFT for digit prediction
      const n = prices.length;
      const frequencies = [];
      
      for (let k = 0; k < 10; k++) {
        let real = 0;
        let imag = 0;
        
        for (let t = 0; t < n; t++) {
          const angle = -2 * Math.PI * k * t / n;
          real += prices[t] * Math.cos(angle);
          imag += prices[t] * Math.sin(angle);
        }
        
        frequencies.push(Math.sqrt(real * real + imag * imag) / n);
      }
      
      // Normalize to probabilities
      const sum = frequencies.reduce((a, b) => a + b, 0) || 1;
      return frequencies.map(f => f / sum);
    }

    // === Trade Execution ===
    async executeTrade(prediction) {
      if (this.inTrade) return;
      
      this.inTrade = true;
      this.lastPrediction = prediction;
      
      const stake = this.calculateOptimalStake(prediction);
      const duration = parseInt(document.getElementById('contractDuration').value);
      
      this.log(`Executing: ${prediction.type} on ${prediction.symbol}, Digit=${prediction.digit}, Confidence=${prediction.confidence.toFixed(1)}%, Stake=$${stake}`, 'info');
      
      // Request proposal
      this.send({
        proposal: 1,
        amount: stake,
        basis: 'stake',
        contract_type: prediction.type,
        currency: this.currency,
        duration: duration,
        duration_unit: 't',
        barrier: prediction.digit.toString(),
        symbol: prediction.symbol
      });
    }

    calculateOptimalStake(prediction) {
      const baseStake = parseFloat(document.getElementById('stake').value);
      const riskPercent = parseFloat(document.getElementById('riskPercent').value) / 100;
      const mode = document.getElementById('tradingMode').value;
      
      // Kelly Criterion
      const p = prediction.probability;
      const q = 1 - p;
      const b = 0.95; // Payout ratio
      const kelly = (p * b - q) / b;
      
      // Apply mode-based safety factor
      const safetyFactor = mode === 'conservative' ? 0.15 : mode === 'balanced' ? 0.20 : 0.25;
      const kellyFraction = Math.max(0, kelly * safetyFactor);
      
      // Calculate stake
      let stake = Math.max(baseStake, this.balance * Math.min(riskPercent, kellyFraction));
      
      // Apply maximum limits
      stake = Math.min(stake, this.balance * 0.02); // Max 2% per trade
      stake = Math.max(stake, 0.35); // Min stake
      
      return Math.round(stake * 100) / 100;
    }

    handleProposal(data) {
      if (!data.proposal || !this.inTrade) return;
      
      // Auto-execute the proposal
      this.send({
        buy: data.proposal.id,
        price: parseFloat(data.echo_req.amount)
      });
    }

    handleBuy(data) {
      if (!data.buy) return;
      
      this.currentContract = data.buy.contract_id;
      this.log(`Trade placed: Contract ${this.currentContract}`, 'success');
      
      // Subscribe to contract updates
      this.send({
        proposal_open_contract: 1,
        contract_id: this.currentContract,
        subscribe: 1
      });
    }

    handleContract(data) {
      const contract = data.proposal_open_contract;
      
      if (!contract || contract.contract_id !== this.currentContract) return;
      
      if (contract.is_expired || contract.is_sold) {
        this.processTradeResult(contract);
      }
    }

    handleTransaction(data) {
      // Additional transaction handling if needed
    }

    processTradeResult(contract) {
      const profit = parseFloat(contract.profit || 0);
      const won = profit > 0;
      
      // Record trade
      const trade = {
        timestamp: Date.now(),
        profit: profit,
        won: won,
        symbol: contract.underlying,
        type: contract.contract_type,
        prediction: this.lastPrediction
      };
      
      this.performance.trades.push(trade);
      this.performance.equity.push(this.balance);
      
      // Update UI
      this.updateTradeHistory(trade);
      this.updateStatistics();
      
      // Log result
      this.log(`Trade ${won ? 'WON' : 'LOST'}: ${profit >= 0 ? '+' : ''}$${profit.toFixed(2)}`, won ? 'success' : 'error');
      
      // Reset
      this.inTrade = false;
      this.currentContract = null;
      this.lastPrediction = null;
      
      // Unsubscribe from contract
      if (data.subscription) {
        this.send({ forget: data.subscription.id });
      }
      
      // Check stop conditions
      this.checkStopConditions();
    }

    checkStopConditions() {
      const pl = this.balance - this.startBalance;
      const target = parseFloat(document.getElementById('targetProfit').value);
      const stopLoss = parseFloat(document.getElementById('stopLoss').value);
      
      if (pl >= target) {
        this.stop();
        this.log(`ðŸŽ¯ Target reached! Profit: $${pl.toFixed(2)}`, 'success');
        alert(`Target Reached!\n\nProfit: $${pl.toFixed(2)}\nFinal Balance: $${this.balance.toFixed(2)}`);
      } else if (Math.abs(pl) >= stopLoss) {
        this.stop();
        this.log(`ðŸ›‘ Stop loss triggered. Loss: $${Math.abs(pl).toFixed(2)}`, 'error');
        alert(`Stop Loss Triggered!\n\nLoss: $${Math.abs(pl).toFixed(2)}\nFinal Balance: $${this.balance.toFixed(2)}`);
      }
    }

    // === Mathematical Functions ===
    calculateHurst(prices) {
      const n = prices.length;
      if (n < 20) return 0.5;
      
      const means = [];
      const ranges = [];
      const stds = [];
      
      for (let lag = 2; lag <= Math.min(n/2, 20); lag++) {
        const segments = Math.floor(n / lag);
        
        for (let i = 0; i < segments; i++) {
          const segment = prices.slice(i * lag, (i + 1) * lag);
          const mean = this.mean(segment);
          
          let cumsum = 0;
          let max = -Infinity;
          let min = Infinity;
          
          segment.forEach(p => {
            cumsum += p - mean;
            max = Math.max(max, cumsum);
            min = Math.min(min, cumsum);
          });
          
          const range = max - min;
          const std = this.std(segment);
          
          if (std > 0) {
            ranges.push(Math.log(range / std));
            means.push(Math.log(lag));
          }
        }
      }
      
      // Linear regression
      const slope = this.linearRegression(means, ranges);
      return Math.max(0, Math.min(1, slope));
    }

    calculateEntropy(digits) {
      const freq = Array(10).fill(0);
      digits.forEach(d => freq[d]++);
      
      const probs = freq.map(f => f / digits.length);
      let entropy = 0;
      
      probs.forEach(p => {
        if (p > 0) {
          entropy -= p * Math.log2(p);
        }
      });
      
      return entropy;
    }

    calculateLyapunov(prices) {
      let sum = 0;
      let count = 0;
      
      for (let i = 1; i < prices.length - 1; i++) {
        const derivative = Math.abs((prices[i+1] - prices[i-1]) / (2 * prices[i]));
        if (derivative > 0) {
          sum += Math.log(derivative);
          count++;
        }
      }
      
      return count > 0 ? sum / count : 0;
    }

    calculateRSI(prices, period = 14) {
      if (prices.length < period + 1) return 50;
      
      let gains = 0;
      let losses = 0;
      
      for (let i = prices.length - period; i < prices.length; i++) {
        const change = prices[i] - prices[i-1];
        if (change > 0) {
          gains += change;
        } else {
          losses -= change;
        }
      }
      
      const avgGain = gains / period;
      const avgLoss = losses / period;
      
      if (avgLoss === 0) return 100;
      
      const rs = avgGain / avgLoss;
      return 100 - (100 / (1 + rs));
    }

    calculateMomentum(prices, period = 10) {
      if (prices.length < period) return 0;
      
      const current = prices[prices.length - 1];
      const past = prices[prices.length - period];
      
      return ((current - past) / past) * 100;
    }

    calculateVolatility(prices) {
      if (prices.length < 2) return 0;
      
      const returns = [];
      for (let i = 1; i < prices.length; i++) {
        returns.push((prices[i] - prices[i-1]) / prices[i-1]);
      }
      
      return this.std(returns) * Math.sqrt(252);
    }

    calculateTrend(prices) {
      if (prices.length < 20) return 0;
      
      const recent = prices.slice(-20);
      const x = Array.from({length: 20}, (_, i) => i);
      
      return this.linearRegression(x, recent);
    }

    calculateDigitFrequency(digits) {
      const freq = Array(10).fill(0);
      digits.forEach(d => freq[d]++);
      return freq.map(f => f / digits.length);
    }

    calculateTransitionMatrix(digits) {
      const matrix = Array(10).fill(0).map(() => Array(10).fill(0));
      
      for (let i = 1; i < digits.length; i++) {
        matrix[digits[i-1]][digits[i]]++;
      }
      
      // Normalize rows
      return matrix.map(row => {
        const sum = row.reduce((a, b) => a + b, 0) || 1;
        return row.map(count => count / sum);
      });
    }

    detectPatterns(digits) {
      const patterns = {
        repeating: 0,
        alternating: 0,
        sequential: 0
      };
      
      for (let i = 2; i < digits.length; i++) {
        if (digits[i] === digits[i-1] && digits[i] === digits[i-2]) {
          patterns.repeating++;
        }
        if (digits[i] === digits[i-2] && digits[i] !== digits[i-1]) {
          patterns.alternating++;
        }
        if (Math.abs(digits[i] - digits[i-1]) === 1) {
          patterns.sequential++;
        }
      }
      
      return patterns;
    }

    skewness(data) {
      const n = data.length;
      const mean = this.mean(data);
      const m3 = data.reduce((a, x) => a + Math.pow(x - mean, 3), 0) / n;
      const m2 = data.reduce((a, x) => a + Math.pow(x - mean, 2), 0) / n;
      
      return m2 > 0 ? m3 / Math.pow(m2, 1.5) : 0;
    }

    kurtosis(data) {
      const n = data.length;
      const mean = this.mean(data);
      const m4 = data.reduce((a, x) => a + Math.pow(x - mean, 4), 0) / n;
      const m2 = data.reduce((a, x) => a + Math.pow(x - mean, 2), 0) / n;
      
      return m2 > 0 ? (m4 / Math.pow(m2, 2)) - 3 : 0;
    }

    linearRegression(x, y) {
      const n = x.length;
      const sumX = x.reduce((a, b) => a + b, 0);
      const sumY = y.reduce((a, b) => a + b, 0);
      const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
      const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);
      
      return (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
    }

    mean(data) {
      return data.reduce((a, b) => a + b, 0) / data.length;
    }

    std(data) {
      const m = this.mean(data);
      const variance = data.reduce((a, x) => a + Math.pow(x - m, 2), 0) / data.length;
      return Math.sqrt(variance);
    }

    // === UI Updates ===
    updateConnectionStatus(status) {
      const statusEl = document.getElementById('connectionStatus');
      const dot = statusEl.querySelector('.status-dot');
      const text = statusEl.querySelector('span:last-child');
      
      dot.className = `status-dot ${status}`;
      
      switch(status) {
        case 'online':
          text.textContent = 'Connected';
          break;
        case 'offline':
          text.textContent = 'Disconnected';
          break;
        case 'connecting':
          text.textContent = 'Connecting...';
          break;
      }
    }

    updatePredictionUI(prediction) {
      document.getElementById('nextPrediction').textContent = prediction.digit;
      document.getElementById('predictionType').textContent = prediction.type;
      document.getElementById('predictionConfidence').textContent = `${prediction.confidence.toFixed(1)}% confidence`;
      
      document.getElementById('bestMarket').textContent = prediction.symbol;
            document.getElementById('marketEdge').textContent = `Edge: ${(prediction.confidence - 10).toFixed(1)}%`;
      
      document.getElementById('tradeSignal').textContent = prediction.type === 'DIGITMATCH' ? 'MATCH' : 'DIFFER';
      document.getElementById('tradeSignal').className = 'text-2xl font-bold pro-glow-green';
      document.getElementById('signalStrength').textContent = `Strength: ${prediction.confidence.toFixed(1)}%`;
      
      // Update digit matrix
      this.updateDigitMatrix(prediction.ensemble);
      
      // Update last update time
      document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
    }

    updateDigitMatrix(probabilities) {
      const matrix = document.getElementById('digitMatrix');
      matrix.innerHTML = '';
      
      const maxProb = Math.max(...probabilities);
      
      probabilities.forEach((prob, digit) => {
        const cell = document.createElement('div');
        cell.className = 'digit-cell';
        
        // Color intensity based on probability
        const intensity = prob / maxProb;
        cell.style.background = `linear-gradient(135deg, rgba(14, 165, 255, ${intensity * 0.4}) 0%, rgba(124, 58, 237, ${intensity * 0.3}) 100%)`;
        
        if (prob === maxProb) {
          cell.classList.add('ring-2', 'ring-blue-400');
        }
        
        cell.innerHTML = `
          <div class="text-2xl font-bold">${digit}</div>
          <div class="text-xs text-gray-400 mt-1">${(prob * 100).toFixed(1)}%</div>
        `;
        
        matrix.appendChild(cell);
      });
    }

    updateIndicators(features) {
      document.getElementById('hurstExponent').textContent = features.hurst.toFixed(3);
      document.getElementById('entropy').textContent = features.entropy.toFixed(2);
      document.getElementById('volatility').textContent = `${(features.volatility * 100).toFixed(1)}%`;
      document.getElementById('momentum').textContent = `${features.momentum.toFixed(1)}%`;
      document.getElementById('trend').textContent = features.trend > 0 ? 'â†‘' : features.trend < 0 ? 'â†“' : 'â†’';
      
      const edge = Math.max(...features.digitFreq) - 0.1;
      document.getElementById('edge').textContent = `${(edge * 100).toFixed(1)}%`;
    }

    updateTradeHistory(trade) {
      const history = document.getElementById('tradeHistory');
      
      const card = document.createElement('div');
      card.className = `glass-morphism rounded-xl p-3 ${trade.won ? 'trade-card-win' : 'trade-card-loss'}`;
      card.innerHTML = `
        <div class="flex justify-between items-center mb-1">
          <span class="text-xs text-gray-400">${new Date(trade.timestamp).toLocaleTimeString()}</span>
          <span class="${trade.won ? 'pro-glow-green' : 'pro-glow-red'} font-bold">
            ${trade.profit >= 0 ? '+' : ''}$${trade.profit.toFixed(2)}
          </span>
        </div>
        <div class="text-xs text-gray-500">
          <span>${trade.symbol}</span> â€¢ 
          <span>${trade.type}</span> â€¢ 
          <span>D: ${trade.prediction?.digit || '-'}</span> â€¢ 
          <span>${trade.prediction?.confidence.toFixed(1) || '-'}%</span>
        </div>
      `;
      
      history.insertBefore(card, history.firstChild);
      
      // Keep only last 20 trades
      while (history.children.length > 20) {
        history.removeChild(history.lastChild);
      }
      
      document.getElementById('tradeCount').textContent = `${this.performance.trades.length} trades`;
    }

    updateStatistics() {
      const trades = this.performance.trades;
      
      if (trades.length === 0) return;
      
      // Basic stats
      const wins = trades.filter(t => t.won).length;
      const losses = trades.length - wins;
      const winRate = (wins / trades.length) * 100;
      
      document.getElementById('totalTrades').textContent = trades.length;
      document.getElementById('wins').textContent = wins;
      document.getElementById('losses').textContent = losses;
      document.getElementById('winRate').textContent = `${winRate.toFixed(1)}%`;
      document.getElementById('winRateBar').style.width = `${winRate}%`;
      
      // Calculate streak
      let currentStreak = 0;
      for (let i = trades.length - 1; i >= 0; i--) {
        if (i === trades.length - 1 || trades[i].won === trades[i + 1].won) {
          currentStreak = trades[i].won ? currentStreak + 1 : currentStreak - 1;
        } else {
          break;
        }
      }
      document.getElementById('streak').textContent = currentStreak > 0 ? `+${currentStreak}` : currentStreak;
      
      // Advanced metrics
      const profits = trades.filter(t => t.won).map(t => t.profit);
      const losses_amounts = trades.filter(t => !t.won).map(t => Math.abs(t.profit));
      
      const totalProfit = profits.reduce((a, b) => a + b, 0) || 0;
      const totalLoss = losses_amounts.reduce((a, b) => a + b, 0) || 0;
      
      // Profit Factor
      const profitFactor = totalLoss > 0 ? totalProfit / totalLoss : totalProfit > 0 ? 999 : 0;
      document.getElementById('profitFactor').textContent = profitFactor > 999 ? 'âˆž' : profitFactor.toFixed(2);
      
      // Expected Value
      const expectedValue = trades.reduce((sum, t) => sum + t.profit, 0) / trades.length;
      document.getElementById('expectedValue').textContent = `$${expectedValue.toFixed(2)}`;
      
      // Sharpe Ratio
      const returns = trades.map(t => t.profit / this.startBalance);
      const avgReturn = this.mean(returns);
      const stdReturn = this.std(returns);
      const sharpe = stdReturn > 0 ? (avgReturn * Math.sqrt(252)) / stdReturn : 0;
      document.getElementById('sharpeRatio').textContent = sharpe.toFixed(2);
      
      // Max Drawdown
      let peak = this.startBalance;
      let maxDD = 0;
      let runningBalance = this.startBalance;
      
      trades.forEach(trade => {
        runningBalance += trade.profit;
        if (runningBalance > peak) peak = runningBalance;
        const dd = (peak - runningBalance) / peak;
        if (dd > maxDD) maxDD = dd;
      });
      
      document.getElementById('maxDrawdown').textContent = `${(maxDD * 100).toFixed(1)}%`;
      
      // Kelly Optimal
      if (wins > 0 && losses > 0) {
        const avgWin = totalProfit / wins;
        const avgLoss = totalLoss / losses;
        const p = winRate / 100;
        const q = 1 - p;
        const b = avgWin / avgLoss;
        const kelly = (p * b - q) / b;
        document.getElementById('kellyOptimal').textContent = `${Math.max(0, Math.min(25, kelly * 100)).toFixed(1)}%`;
      }
      
      // Update equity chart
      this.updateEquityChart();
    }

    updatePerformance() {
      const pl = this.balance - this.startBalance;
      const roi = this.startBalance > 0 ? (pl / this.startBalance) * 100 : 0;
      
      document.getElementById('sessionPL').textContent = `${pl >= 0 ? '+' : ''}$${pl.toFixed(2)}`;
      document.getElementById('sessionPL').className = pl >= 0 ? 'text-2xl font-black pro-glow-green' : 'text-2xl font-black pro-glow-red';
      
      document.getElementById('roi').textContent = `${roi >= 0 ? '+' : ''}${roi.toFixed(1)}%`;
      document.getElementById('roi').className = roi >= 0 ? 'text-lg font-bold pro-glow-green' : 'text-lg font-bold pro-glow-red';
    }

    updatePriceChart(prices) {
      if (!window.priceChart || prices.length < 2) return;
      
      const displayPrices = prices.slice(-50);
      
      window.priceChart.data.labels = displayPrices.map((_, i) => i);
      window.priceChart.data.datasets[0].data = displayPrices;
      window.priceChart.update('none');
    }

    updateEquityChart() {
      if (!window.equityChart) return;
      
      const equity = [this.startBalance];
      let runningBalance = this.startBalance;
      
      this.performance.trades.forEach(trade => {
        runningBalance += trade.profit;
        equity.push(runningBalance);
      });
      
      window.equityChart.data.labels = equity.map((_, i) => i);
      window.equityChart.data.datasets[0].data = equity;
      window.equityChart.update('none');
    }

    // === Utility Functions ===
    subscribeToMarkets() {
      const markets = this.getActiveMarkets();
      markets.forEach(symbol => {
        this.send({ ticks: symbol, subscribe: 1 });
      });
      this.log(`Subscribed to ${markets.length} markets`, 'success');
    }

    getActiveMarkets() {
      return ['R_10', 'R_25', 'R_50', 'R_75', 'R_100', '1HZ10V']
        .filter(id => document.getElementById(id)?.checked);
    }

    extractDigit(price) {
      return parseInt(price.toFixed(2).slice(-1));
    }

    async start() {
      if (!this.initialized) {
        await this.initialize();
      }
      
      this.running = true;
      document.getElementById('botStatus').textContent = 'RUNNING';
      document.getElementById('botStatus').className = 'font-bold pro-glow-green neural-pulse';
      
      document.getElementById('startBtn').disabled = true;
      document.getElementById('stopBtn').disabled = false;
      
      this.log('AI Trading started', 'success');
    }

    stop() {
      this.running = false;
      document.getElementById('botStatus').textContent = 'STOPPED';
      document.getElementById('botStatus').className = 'font-bold pro-glow-yellow';
      
      document.getElementById('startBtn').disabled = false;
      document.getElementById('stopBtn').disabled = true;
      
      this.log('AI Trading stopped', 'warning');
    }

    send(message) {
      if (this.ws?.readyState === 1) {
        message.req_id = message.req_id || Date.now();
        this.ws.send(JSON.stringify(message));
      }
    }

    log(message, type = 'info') {
      const time = new Date().toLocaleTimeString();
      const logContainer = document.getElementById('systemLog');
      
      const entry = document.createElement('div');
      entry.className = `log-entry log-${type}`;
      entry.innerHTML = `<span class="text-gray-500">[${time}]</span> ${message}`;
      
      logContainer.appendChild(entry);
      logContainer.scrollTop = logContainer.scrollHeight;
      
      // Keep only last 100 entries
      while (logContainer.children.length > 100) {
        logContainer.removeChild(logContainer.firstChild);
      }
      
      console.log(`[${time}] ${message}`);
    }
  }

  // === Microstructure Analyzer ===
  class MicrostructureAnalyzer {
    constructor() {
      this.patterns = new Map();
      this.volumeProfile = new Map();
    }

    analyze(data) {
      const prices = data.prices;
      const digits = data.digits;
      const timestamps = data.timestamps;
      
      return {
        tickVelocity: this.calculateTickVelocity(timestamps),
        tickAcceleration: this.calculateTickAcceleration(timestamps),
        microVolatility: this.calculateMicroVolatility(prices),
        bidAskSpread: this.estimateBidAskSpread(prices),
        orderFlow: this.estimateOrderFlow(prices),
        absorption: this.detectAbsorption(prices),
        accumulation: this.detectAccumulation(prices, digits),
        distribution: this.detectDistribution(prices, digits)
      };
    }

    predict(microstructure) {
      const predictions = Array(10).fill(0.1);
      
      // Adjust predictions based on microstructure
      if (microstructure.accumulation > 0.7) {
        predictions[7] += 0.05;
        predictions[8] += 0.05;
        predictions[9] += 0.05;
      }
      
      if (microstructure.distribution > 0.7) {
        predictions[0] += 0.05;
        predictions[1] += 0.05;
        predictions[2] += 0.05;
      }
      
      if (microstructure.tickVelocity > 0) {
        const momentum = Math.min(0.1, Math.abs(microstructure.tickVelocity));
        predictions[5] += momentum;
      }
      
      // Normalize
      const sum = predictions.reduce((a, b) => a + b, 0);
      return predictions.map(p => p / sum);
    }

    calculateTickVelocity(timestamps) {
      if (timestamps.length < 2) return 0;
      
      const intervals = [];
      for (let i = 1; i < timestamps.length; i++) {
        intervals.push(timestamps[i] - timestamps[i-1]);
      }
      
      const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
      const recentInterval = intervals[intervals.length - 1];
      
      return (avgInterval - recentInterval) / avgInterval;
    }

    calculateTickAcceleration(timestamps) {
      if (timestamps.length < 3) return 0;
      
      const velocities = [];
      for (let i = 2; i < timestamps.length; i++) {
        const v1 = 1 / (timestamps[i-1] - timestamps[i-2]);
        const v2 = 1 / (timestamps[i] - timestamps[i-1]);
        velocities.push(v2 - v1);
      }
      
      return velocities.length > 0 ? velocities[velocities.length - 1] : 0;
    }

    calculateMicroVolatility(prices) {
      if (prices.length < 10) return 0;
      
      const recent = prices.slice(-10);
      const returns = [];
      
      for (let i = 1; i < recent.length; i++) {
        returns.push((recent[i] - recent[i-1]) / recent[i-1]);
      }
      
      const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
      const variance = returns.reduce((a, r) => a + Math.pow(r - mean, 2), 0) / returns.length;
      
      return Math.sqrt(variance);
    }

    estimateBidAskSpread(prices) {
      if (prices.length < 20) return 0;
      
      const changes = [];
      for (let i = 1; i < prices.length; i++) {
        if (prices[i] !== prices[i-1]) {
          changes.push(Math.abs(prices[i] - prices[i-1]));
        }
      }
      
      if (changes.length === 0) return 0;
      
      changes.sort((a, b) => a - b);
      return changes[Math.floor(changes.length * 0.25)]; // 25th percentile as spread estimate
    }

    estimateOrderFlow(prices) {
      if (prices.length < 10) return 0;
      
      let buyPressure = 0;
      let sellPressure = 0;
      
      for (let i = 1; i < prices.length; i++) {
        const change = prices[i] - prices[i-1];
        if (change > 0) {
          buyPressure += change;
        } else {
          sellPressure += Math.abs(change);
        }
      }
      
      const total = buyPressure + sellPressure;
      return total > 0 ? (buyPressure - sellPressure) / total : 0;
    }

    detectAbsorption(prices) {
      if (prices.length < 20) return 0;
      
      const recent = prices.slice(-20);
      const volatility = this.calculateMicroVolatility(recent);
      const range = Math.max(...recent) - Math.min(...recent);
      
      // Low volatility with tight range indicates absorption
      return volatility > 0 ? Math.exp(-range / volatility) : 0;
    }

    detectAccumulation(prices, digits) {
      if (prices.length < 50) return 0;
      
      const recentPrices = prices.slice(-50);
      const recentDigits = digits.slice(-50);
      
      // Check if higher digits are becoming more frequent
      const firstHalf = recentDigits.slice(0, 25);
      const secondHalf = recentDigits.slice(25);
      
      const avgFirst = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
      const avgSecond = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
      
      return Math.max(0, Math.min(1, (avgSecond - avgFirst) / 5));
    }

    detectDistribution(prices, digits) {
      if (prices.length < 50) return 0;
      
      const recentDigits = digits.slice(-50);
      
      // Check if lower digits are becoming more frequent
      const firstHalf = recentDigits.slice(0, 25);
      const secondHalf = recentDigits.slice(25);
      
      const avgFirst = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
      const avgSecond = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
      
      return Math.max(0, Math.min(1, (avgFirst - avgSecond) / 5));
    }
  }

  // === Hidden Markov Model ===
  class HiddenMarkovModel {
    constructor() {
      this.states = ['trending_up', 'trending_down', 'ranging', 'volatile'];
      this.transitions = [
        [0.7, 0.1, 0.1, 0.1],
        [0.1, 0.7, 0.1, 0.1],
        [0.1, 0.1, 0.7, 0.1],
        [0.25, 0.25, 0.25, 0.25]
      ];
      this.emissions = this.initializeEmissions();
      this.currentState = 2; // Start with ranging
    }

    initializeEmissions() {
      // Emission probabilities for each state to each digit
      return [
        [0.05, 0.05, 0.08, 0.08, 0.10, 0.12, 0.12, 0.15, 0.15, 0.10], // trending_up
        [0.15, 0.15, 0.12, 0.12, 0.10, 0.08, 0.08, 0.05, 0.05, 0.10], // trending_down
        [0.10, 0.10, 0.10, 0.10, 0.10, 0.10, 0.10, 0.10, 0.10, 0.10], // ranging
        [0.08, 0.08, 0.08, 0.08, 0.08, 0.12, 0.12, 0.12, 0.12, 0.12]  // volatile
      ];
    }

    detectRegime(prices) {
      if (prices.length < 20) return 'unknown';
      
      const recent = prices.slice(-20);
      const returns = [];
      
      for (let i = 1; i < recent.length; i++) {
        returns.push((recent[i] - recent[i-1]) / recent[i-1]);
      }
      
      const meanReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
      const volatility = Math.sqrt(returns.reduce((a, r) => a + Math.pow(r - meanReturn, 2), 0) / returns.length);
      
      // Determine state based on metrics
      if (Math.abs(meanReturn) > 0.001 && volatility < 0.002) {
        this.currentState = meanReturn > 0 ? 0 : 1; // Trending
      } else if (volatility > 0.003) {
        this.currentState = 3; // Volatile
      } else {
        this.currentState = 2; // Ranging
      }
      
      return this.states[this.currentState];
    }

    predict(digits) {
      if (digits.length < 10) {
        return Array(10).fill(0.1);
      }
      
      // Get emission probabilities for current state
      const emissions = this.emissions[this.currentState];
      
      // Adjust based on recent patterns
      const recentDigits = digits.slice(-10);
      const freq = Array(10).fill(0);
      recentDigits.forEach(d => freq[d]++);
      
      // Combine emissions with recent frequency
      const predictions = emissions.map((e, i) => e * 0.7 + (freq[i] / 10) * 0.3);
      
      // Normalize
      const sum = predictions.reduce((a, b) => a + b, 0);
      return predictions.map(p => p / sum);
    }

    viterbi(observations) {
      // Simplified Viterbi algorithm for state sequence
      const T = observations.length;
      const N = this.states.length;
      
      const delta = Array(T).fill(0).map(() => Array(N).fill(0));
      const psi = Array(T).fill(0).map(() => Array(N).fill(0));
      
      // Initialization
      for (let i = 0; i < N; i++) {
        delta[0][i] = this.emissions[i][observations[0]];
      }
      
      // Recursion
      for (let t = 1; t < T; t++) {
        for (let j = 0; j < N; j++) {
          let maxVal = -Infinity;
          let maxState = 0;
          
          for (let i = 0; i < N; i++) {
            const val = delta[t-1][i] * this.transitions[i][j];
            if (val > maxVal) {
              maxVal = val;
              maxState = i;
            }
          }
          
          delta[t][j] = maxVal * this.emissions[j][observations[t]];
          psi[t][j] = maxState;
        }
      }
      
      // Backtrack
      const path = Array(T).fill(0);
      path[T-1] = delta[T-1].indexOf(Math.max(...delta[T-1]));
      
      for (let t = T-2; t >= 0; t--) {
        path[t] = psi[t+1][path[t+1]];
      }
      
      return path;
    }
  }

  // === Initialize System ===
  const AI = new ProLiteAISystem();

  // === Initialize Charts ===
  function initializeCharts() {
    const chartConfig = {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false }
      },
      scales: {
        x: {
          display: false,
          grid: { display: false }
        },
        y: {
          display: true,
          grid: {
            color: 'rgba(255, 255, 255, 0.05)',
            drawBorder: false
          },
          ticks: {
            color: 'rgba(255, 255, 255, 0.5)',
            font: { size: 10 }
          }
        }
      }
    };

    // Price Chart
    const priceCtx = document.getElementById('priceChart').getContext('2d');
    window.priceChart = new Chart(priceCtx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [{
          data: [],
          borderColor: '#0ea5ff',
          backgroundColor: 'rgba(14, 165, 255, 0.1)',
          borderWidth: 2,
          tension: 0.4,
          pointRadius: 0,
          fill: true
        }]
      },
      options: chartConfig
    });

    // Equity Chart
    const equityCtx = document.getElementById('equityChart').getContext('2d');
    window.equityChart = new Chart(equityCtx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [{
          data: [],
          borderColor: '#00d4aa',
          backgroundColor: 'rgba(0, 212, 170, 0.1)',
          borderWidth: 2,
          tension: 0.1,
          pointRadius: 0,
          fill: true
        }]
      },
      options: {
        ...chartConfig,
        scales: {
          ...chartConfig.scales,
          y: {
            ...chartConfig.scales.y,
            ticks: {
              ...chartConfig.scales.y.ticks,
              callback: function(value) {
                return '$' + value.toFixed(0);
              }
            }
          }
        }
      }
    });
  }

  // === Event Listeners ===
  document.getElementById('connectBtn').addEventListener('click', async () => {
    try {
      const btn = document.getElementById('connectBtn');
      btn.disabled = true;
      btn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i> Connecting...';
      
      await AI.connect();
      
      btn.innerHTML = '<i class="fas fa-check mr-2"></i> Connected';
      document.getElementById('startBtn').disabled = false;
      
      AI.log('Connected successfully', 'success');
      
    } catch (error) {
      document.getElementById('connectBtn').disabled = false;
      document.getElementById('connectBtn').innerHTML = '<i class="fas fa-plug mr-2"></i> Connect to Deriv';
      AI.log(`Connection failed: ${error.message}`, 'error');
      alert(`Connection failed: ${error.message}`);
    }
  });

  document.getElementById('startBtn').addEventListener('click', async () => {
    await AI.start();
  });

  document.getElementById('stopBtn').addEventListener('click', () => {
    AI.stop();
  });

  document.getElementById('minConfidence').addEventListener('input', (e) => {
    document.getElementById('confidenceValue').textContent = `${e.target.value}%`;
  });

  document.getElementById('clearLog').addEventListener('click', () => {
    document.getElementById('systemLog').innerHTML = `
      <div class="log-entry log-info">
        <span class="text-gray-500">[${new Date().toLocaleTimeString()}]</span> Log cleared
      </div>
    `;
  });

  // === Real-time Updates ===
  setInterval(() => {
    // Update server time
    document.getElementById('serverTime').textContent = new Date().toLocaleTimeString();
    
    // Update ping if connected
    if (AI.connected) {
      const ping = Date.now() - AI.lastPing;
      document.getElementById('ping').textContent = `Ping: ${ping}ms`;
    }
    
    // Update AI status indicator
    const statusEl = document.getElementById('aiStatus');
    if (AI.running && !AI.inTrade) {
      statusEl.innerHTML = '<span class="loading-spinner" style="width: 16px; height: 16px; border-width: 2px;"></span> Analyzing';
    } else if (AI.inTrade) {
      statusEl.innerHTML = '<i class="fas fa-chart-line text-yellow-500"></i> In Trade';
    } else {
      statusEl.innerHTML = '<i class="fas fa-pause text-gray-500"></i> Idle';
    }
  }, 1000);

  // === Initialize on Load ===
  window.addEventListener('load', async () => {
    initializeCharts();
    
    try {
      await AI.initialize();
      AI.log('System ready. Enter API token and click Connect to begin.', 'success');
    } catch (error) {
      AI.log('Failed to initialize AI system', 'error');
    }
  });

})();
</script>

</body>
</html>